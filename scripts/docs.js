const { ESLint } = require('eslint');
const fs = require('node:fs/promises');
const path = require('node:path');
const { execSync } = require('node:child_process');
const {
  configRulesToMarkdown,
  configsToMarkdown,
} = require('./helpers/format');
const { configs } = require('./helpers/configs');
const { ruleLevelFromEntry } = require('./helpers/rules');

const readmePath = path.join(__dirname, '..', 'README.md');
const docsDir = path.join(__dirname, '..', 'docs');

async function generateDocs() {
  execSync('npm link');
  execSync('npm link @code-pushup/eslint-config');

  try {
    await fs.mkdir(docsDir, { recursive: true });

    for (const config of configs) {
      await generateConfigDocs(config);
    }

    await generateReadmeDocs();
  } finally {
    execSync('npm unlink @code-pushup/eslint-config');
  }
}

async function generateReadmeDocs() {
  const buffer = await fs.readFile(readmePath);
  const mdPrevious = buffer.toString('utf8');

  const startComment = '<!-- begin autogenerated -->';
  const endComment = '<!-- end autogenerated -->';

  const startIndex = mdPrevious.indexOf(startComment);
  const endIndex = mdPrevious.indexOf(
    endComment,
    startIndex + startComment.length,
  );

  const mdGenerated = configsToMarkdown(configs);
  const mdGeneratedBlock = [
    startComment,
    mdGenerated.replace(/\n$/, ''),
    endComment,
  ].join('\n\n');

  const mdUpdated =
    startIndex < 0
      ? [mdPrevious, mdGeneratedBlock].join('\n')
      : [
          mdPrevious.slice(0, startIndex),
          mdGeneratedBlock,
          mdPrevious.slice(endIndex + endComment.length),
        ].join('');

  await fs.writeFile(readmePath, mdUpdated);

  console.info(`Updated Markdown docs in ${readmePath}`);
}

/**
 * Generate Markdown file for specified ESLint config.
 * @param {string} name Config file name without extension
 */
async function generateConfigDocs(name) {
  const eslint = new ESLint({
    baseConfig: { extends: `./${name}.js` },
    useEslintrc: false,
  });

  /** @type {import('eslint').Linter.Config} */
  const config = await eslint.calculateConfigForFile('*.ts');
  /** @type {import('eslint').Linter.Config} */
  const testConfig = await eslint.calculateConfigForFile('*.test.ts');
  const mergedRules = { ...testConfig.rules, ...config.rules };
  const ruleIds = Object.entries(mergedRules)
    .filter(([, entry]) => ruleLevelFromEntry(entry) !== 'off')
    .map(([ruleId]) => ruleId);
  const rules = eslint.getRulesMetaForResults([
    {
      messages: ruleIds.map(ruleId => ({ ruleId })),
      suppressedMessages: [],
    },
  ]);

  const markdown = configRulesToMarkdown(
    name,
    ruleIds.map(id => {
      const entry = config.rules[id];
      const level = ruleLevelFromEntry(entry);
      const testLevel = ruleLevelFromEntry(testConfig.rules[id]);
      return {
        id,
        meta: rules[id],
        level,
        ...(Array.isArray(entry) && {
          options: entry.slice(1),
        }),
        ...(testLevel !== level && {
          testOverride: {
            level: testLevel,
          },
        }),
      };
    }),
  );

  const filePath = path.join(docsDir, `${name}.md`);
  await fs.writeFile(filePath, markdown);

  console.info(`Generated Markdown docs in ${filePath}`);
}

if (require.main === module) {
  generateDocs().catch(console.error);
}
