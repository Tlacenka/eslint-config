const { ESLint } = require('eslint');
const fs = require('node:fs/promises');
const path = require('node:path');
const { execSync } = require('node:child_process');
const {
  configRulesToMarkdown,
  configsToMarkdown,
} = require('./helpers/format');
const {
  configs,
  configPattern,
  isConfigForTests,
  getConfigExtends,
  configExtraPattern,
} = require('./helpers/configs');
const { ruleLevelFromEntry, getEnabledRuleIds } = require('./helpers/rules');

const readmePath = path.join(__dirname, '..', 'README.md');
const docsDir = path.join(__dirname, '..', 'docs');

async function generateDocs() {
  execSync('npm link');
  execSync('npm link @code-pushup/eslint-config');

  try {
    await fs.mkdir(docsDir, { recursive: true });

    for (const config of configs) {
      await generateConfigDocs(config);
    }

    await generateReadmeDocs();
  } finally {
    execSync('npm unlink @code-pushup/eslint-config');
  }
}

async function generateReadmeDocs() {
  const buffer = await fs.readFile(readmePath);
  const mdPrevious = buffer.toString('utf8');

  const startComment = '<!-- begin autogenerated -->';
  const endComment = '<!-- end autogenerated -->';

  const startIndex = mdPrevious.indexOf(startComment);
  const endIndex = mdPrevious.indexOf(
    endComment,
    startIndex + startComment.length,
  );

  const mdGenerated = configsToMarkdown(configs);
  const mdGeneratedBlock = [
    startComment,
    mdGenerated.replace(/\n$/, ''),
    endComment,
  ].join('\n\n');

  const mdUpdated =
    startIndex < 0
      ? [mdPrevious, mdGeneratedBlock].join('\n')
      : [
          mdPrevious.slice(0, startIndex),
          mdGeneratedBlock,
          mdPrevious.slice(endIndex + endComment.length),
        ].join('');

  await fs.writeFile(readmePath, mdUpdated);

  console.info(`Updated Markdown docs in ${readmePath}`);
}

/**
 * Generate Markdown file for specified ESLint config.
 * @param {string} name Config file name without extension
 */
async function generateConfigDocs(name) {
  const eslint = new ESLint({
    baseConfig: { extends: `./${name}.js` },
    useEslintrc: false,
  });

  /** @type {import('eslint').Linter.Config} */
  const config = await eslint.calculateConfigForFile(configPattern(name));

  /** @type {import('eslint').Linter.Config | null} */
  const configExtra = configExtraPattern(name)
    ? await eslint.calculateConfigForFile(configExtraPattern(name))
    : null;

  /** @type {import('eslint').Linter.Config} */
  const testConfig = await eslint.calculateConfigForFile('*.test.ts');

  const extendedConfigs = await getConfigExtends(name)
    .filter(alias => alias.startsWith('@code-pushup'))
    .reduce(
      /** @param {Promise<Record<string, string[]>>} acc  */
      async (acc, alias) => {
        const record = await acc;
        const eslint = new ESLint({
          baseConfig: { extends: alias },
          useEslintrc: false,
        });
        /** @type {import('eslint').Linter.Config} */
        const { rules } = await eslint.calculateConfigForFile(
          configPattern(name),
        );
        return {
          ...record,
          [alias]: getEnabledRuleIds(rules),
        };
      },
      Promise.resolve({}),
    );
  const extendedRuleIds = Object.values(extendedConfigs).flat();

  const ruleIds = getEnabledRuleIds({
    ...testConfig.rules,
    ...config.rules,
    ...configExtra?.rules,
  }).filter(ruleId => !extendedRuleIds.includes(ruleId));
  const rules = eslint.getRulesMetaForResults([
    {
      messages: ruleIds.map(ruleId => ({ ruleId })),
      suppressedMessages: [],
    },
  ]);

  const markdown = configRulesToMarkdown(
    name,
    ruleIds.map(id => {
      const entry = config.rules[id] ?? configExtra?.rules[id];
      const level = ruleLevelFromEntry(entry);
      const testLevel = ruleLevelFromEntry(testConfig.rules[id]);
      return {
        id,
        meta: rules[id],
        level,
        ...(Array.isArray(entry) &&
          entry.length > 1 && {
            options: entry.slice(1),
          }),
        ...(testLevel &&
          testLevel !== level && {
            testOverride: {
              level: testLevel,
            },
          }),
      };
    }),
    Object.entries(extendedConfigs).map(([alias, rules]) => ({
      alias,
      rulesCount: rules.length,
    })),
    {
      hideOverrides: isConfigForTests(name),
    },
  );

  const filePath = path.join(docsDir, `${name}.md`);
  await fs.writeFile(filePath, markdown);

  console.info(`Generated Markdown docs in ${filePath}`);
}

if (require.main === module) {
  generateDocs().catch(console.error);
}
